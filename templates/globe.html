<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manager Gate</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }

        #info {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: 'Courier New', Courier, monospace;
            pointer-events: none;
            z-index: 10;
            text-shadow: 0 0 5px #000;
        }

        h1 {
            margin: 0;
            font-size: 24px;
            letter-spacing: 2px;
        }

        p {
            font-size: 14px;
            color: #aaa;
        }

        #info a,
        #info button {
            pointer-events: auto;
        }

        .btn {
            display: inline-block;
            margin: 10px 5px;
            padding: 10px 20px;
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 25px;
            color: white;
            text-decoration: none;
            font-family: sans-serif;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.25);
            transition: all 0.3s ease;
            cursor: pointer;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.4);
            border-color: white;
        }

        .btn-reset {
            background: rgba(255, 100, 100, 0.3);
            border-color: rgba(255, 100, 100, 0.8);
        }

        .btn-reset:hover {
            background: rgba(255, 100, 100, 0.5);
        }

        #tooltip,
        #challenge-status,
        #challenge-display {
            position: absolute;
            display: none;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-family: sans-serif;
            font-size: 12px;
            pointer-events: none;
            border: 1px solid rgba(255, 255, 255, 0.3);
            z-index: 100;
        }

        #challenge-status {
            bottom: 20px;
            right: 20px;
            display: block;
            color: #ffd700;
            font-size: 14px;
            font-weight: bold;
        }

        #challenge-display {
            top: 100px;
            left: 20px;
            display: none;
            padding: 15px 20px;
            font-size: 16px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ffd700;
            max-width: 300px;
        }

        #challenge-display h3 {
            margin: 0 0 10px 0;
            color: #ffd700;
            font-size: 18px;
        }

        #challenge-display ul {
            margin: 5px 0;
            padding-left: 20px;
            list-style: none;
        }

        #challenge-display li {
            margin: 5px 0;
            color: #fff;
            font-size: 14px;
        }

        #challenge-display li::before {
            content: "üéØ ";
            margin-right: 5px;
        }
    </style>
</head>

<body>
    <div id="info">
        <h1>SECURE GATE</h1>
        <p>Left-Click: Rotate | Right-Click: Mark Countries</p>
        <a href="/" class="btn">‚Üê Back to Home</a>
        <button class="btn btn-reset" onclick="resetChallenge()">Reset Challenge</button>
    </div>
    <div id="tooltip"></div>
    <div id="challenge-status">Challenge: Click 3 countries...</div>
    <div id="challenge-display">
        <h3>üéØ Target Countries</h3>
        <ul id="target-countries"></ul>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        let scene, camera, renderer, controls, earth;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const tooltip = document.getElementById('tooltip');
        const challengeStatus = document.getElementById('challenge-status');
        const challengeDisplay = document.getElementById('challenge-display');
        const targetCountriesList = document.getElementById('target-countries');
        let countries = [];
        let clickedCountries = [];
        let clickedPoints = [];
        let markers = [];
        let lines = [];
        let challengeCountries = [];

        function init() {
            console.log("Globe v3.1 - Challenge Display");
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510);
            scene.fog = new THREE.FogExp2(0x050510, 0.002);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 15;
            camera.position.y = 5;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const geometry = new THREE.SphereGeometry(5, 64, 64);
            const material = new THREE.MeshPhongMaterial({
                color: 0xffffff, specular: new THREE.Color(0x333333), shininess: 5
            });
            earth = new THREE.Mesh(geometry, material);
            earth.name = "Earth";
            scene.add(earth);

            const textureLoader = new THREE.TextureLoader();
            textureLoader.load('/static/earth_texture.jpg',
                (texture) => { earth.material.map = texture; earth.material.needsUpdate = true; },
                undefined,
                (err) => { earth.material.color.setHex(0x2a5f8a); }
            );

            loadBorders();

            scene.add(new THREE.AmbientLight(0x888888));
            const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
            sunLight.position.set(5, 3, 5);
            scene.add(sunLight);

            addStars();

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: -1 };

            renderer.domElement.addEventListener('contextmenu', (e) => { e.preventDefault(); handleRightClick(e); });
            renderer.domElement.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('resize', onWindowResize);

            earth.rotation.y = -1.5;
            earth.rotation.x = 0.2;

            loadCurrentChallenge();
            animate();
        }

        function handleMouseMove(e) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(earth);

            if (intersects.length > 0) {
                const point = intersects[0].point.clone();
                earth.worldToLocal(point);

                const phi = Math.acos(point.y / 5);
                const theta = Math.atan2(point.z, -point.x);
                const lat = 90 - (phi * 180 / Math.PI);
                let lon = (theta * 180 / Math.PI) - 180;
                if (lon < -180) lon += 360;
                if (lon > 180) lon -= 360;

                const hovered = countries.find(c =>
                    lat >= c.bbox.minLat && lat <= c.bbox.maxLat &&
                    lon >= c.bbox.minLon && lon <= c.bbox.maxLon &&
                    isPointInCountry(lat, lon, c)
                );

                if (hovered) {
                    tooltip.style.display = 'block';
                    tooltip.style.left = (e.clientX + 15) + 'px';
                    tooltip.style.top = (e.clientY + 15) + 'px';
                    tooltip.innerText = hovered.name;
                } else {
                    tooltip.style.display = 'none';
                }
            } else {
                tooltip.style.display = 'none';
            }
        }

        function handleRightClick(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);

            const earthHit = intersects.find(h => h.object === earth);
            if (earthHit) {
                const point = earthHit.point.clone();
                earth.worldToLocal(point);

                const phi = Math.acos(point.y / 5);
                const theta = Math.atan2(point.z, -point.x);
                const lat = 90 - (phi * 180 / Math.PI);
                let lon = (theta * 180 / Math.PI) - 180;
                if (lon < -180) lon += 360; if (lon > 180) lon -= 360;

                const clicked = countries.find(c =>
                    lat >= c.bbox.minLat && lat <= c.bbox.maxLat &&
                    lon >= c.bbox.minLon && lon <= c.bbox.maxLon &&
                    isPointInCountry(lat, lon, c)
                );

                if (clicked) {
                    if (clickedCountries.includes(clicked.name)) {
                        console.log("Already clicked:", clicked.name);
                        return;
                    }

                    if (clickedCountries.length === 3) {
                        resetMarks();
                        return;
                    }

                    clickedCountries.push(clicked.name);
                    console.log("Clicked country:", clicked.name);

                    point.multiplyScalar(1.02);
                    clickedPoints.push(point);

                    const newMarker = new THREE.Mesh(
                        new THREE.SphereGeometry(0.15, 16, 16),
                        new THREE.MeshBasicMaterial({ color: 0xffd700, depthTest: false })
                    );
                    newMarker.position.copy(point);
                    newMarker.renderOrder = 999;
                    earth.add(newMarker);
                    markers.push(newMarker);

                    if (clickedPoints.length >= 2) {
                        const p1 = clickedPoints[clickedPoints.length - 2];
                        const p2 = clickedPoints[clickedPoints.length - 1];
                        const curve = createEarthArc(p1, p2);
                        const points = curve.getPoints(100);

                        const geometry = new THREE.BufferGeometry().setFromPoints(points);
                        const material = new THREE.LineBasicMaterial({
                            color: 0xff6b35, depthTest: false, transparent: true, opacity: 0.9
                        });
                        const line = new THREE.Line(geometry, material);
                        line.renderOrder = 998;
                        earth.add(line);
                        lines.push(line);
                    }

                    updateChallengeStatus();

                    if (clickedCountries.length === 3) {
                        verifyChallenge();
                    }
                }
            }
        }

        function resetMarks() {
            clickedCountries = [];
            clickedPoints = [];
            markers.forEach(m => earth.remove(m));
            markers = [];
            lines.forEach(l => earth.remove(l));
            lines = [];
            updateChallengeStatus();
        }

        function updateChallengeStatus() {
            if (clickedCountries.length === 0) {
                challengeStatus.innerText = `Challenge: Click 3 countries...`;
            } else {
                challengeStatus.innerText = `Clicked (${clickedCountries.length}/3): ${clickedCountries.join(', ')}`;
            }
        }

        function loadCurrentChallenge() {
            fetch('/api/challenge/current')
                .then(r => r.json())
                .then(data => {
                    if (data.status === 'success') {
                        challengeCountries = data.countries;
                        displayChallengeCountries(challengeCountries);
                        console.log("Challenge countries:", challengeCountries);
                    } else {
                        resetChallenge();
                    }
                });
        }

        function displayChallengeCountries(countries) {
            targetCountriesList.innerHTML = '';
            countries.forEach(country => {
                const li = document.createElement('li');
                li.textContent = country;
                targetCountriesList.appendChild(li);
            });
            challengeDisplay.style.display = 'block';
        }

        function resetChallenge() {
            fetch('/api/challenge/generate', { method: 'POST' })
                .then(r => r.json())
                .then(data => {
                    if (data.status === 'success') {
                        challengeCountries = data.countries;
                        displayChallengeCountries(challengeCountries);
                        console.log("New challenge:", challengeCountries);
                        resetMarks();
                    }
                });
        }

        function verifyChallenge() {
            fetch('/api/challenge/verify', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ countries: clickedCountries })
            })
                .then(r => r.json())
                .then(data => {
                    if (data.status === 'success') {
                        alert('‚úÖ Challenge Passed! Redirecting to dashboard...');
                        window.location.href = '/manager/dashboard';
                    } else {
                        alert(`‚ùå Wrong countries!\\nYou clicked: ${clickedCountries.join(', ')}\\nTry again.`);
                        resetMarks();
                    }
                });
        }

        function createEarthArc(p1, p2) {
            const angle = p1.angleTo(p2);
            const numPoints = Math.max(50, Math.floor(angle * 100));
            const points = [];
            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                const slerp = new THREE.Vector3().lerpVectors(p1, p2, t).normalize();
                const arcPoint = slerp.multiplyScalar(p1.length() * 1.02);
                points.push(arcPoint);
            }
            return new THREE.CatmullRomCurve3(points);
        }

        function loadBorders() {
            fetch('/static/countries.geojson').then(r => r.json()).then(data => {
                const material = new THREE.LineBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.8 });
                countries = [];

                data.features.forEach(f => {
                    const coords = f.geometry.coordinates;
                    const name = f.properties.ADMIN || f.properties.name || "Unknown";

                    if (f.geometry.type === 'Polygon') coords.forEach(r => drawRing(r, material));
                    else if (f.geometry.type === 'MultiPolygon') coords.forEach(p => p.forEach(r => drawRing(r, material)));

                    const bbox = { minLat: 90, maxLat: -90, minLon: 180, maxLon: -180 };
                    const updateBBox = (ring) => ring.forEach(c => {
                        if (c[1] < bbox.minLat) bbox.minLat = c[1];
                        if (c[1] > bbox.maxLat) bbox.maxLat = c[1];
                        if (c[0] < bbox.minLon) bbox.minLon = c[0];
                        if (c[0] > bbox.maxLon) bbox.maxLon = c[0];
                    });

                    if (f.geometry.type === 'Polygon') updateBBox(coords[0]);
                    else if (f.geometry.type === 'MultiPolygon') coords.forEach(p => updateBBox(p[0]));

                    countries.push({ name: name, type: f.geometry.type, coordinates: coords, bbox: bbox });
                });
                console.log("Countries:", countries.length);
            });
        }

        function isPointInCountry(lat, lon, country) {
            if (country.type === 'Polygon') return isPointInPolygon(lat, lon, country.coordinates);
            else if (country.type === 'MultiPolygon') return country.coordinates.some(p => isPointInPolygon(lat, lon, p));
            return false;
        }

        function isPointInPolygon(lat, lon, polygon) {
            const ring = polygon[0];
            let inside = false;
            for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
                const xi = ring[i][0], yi = ring[i][1];
                const xj = ring[j][0], yj = ring[j][1];
                const intersect = ((yi > lat) !== (yj > lat)) && (lon < (xj - xi) * (lat - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        function drawRing(ring, material) {
            const points = ring.map(c => {
                const lat = c[1], lon = c[0], radius = 5.05;
                const phi = (90 - lat) * (Math.PI / 180);
                const theta = (lon + 180) * (Math.PI / 180);
                return new THREE.Vector3(
                    -(radius * Math.sin(phi) * Math.cos(theta)),
                    (radius * Math.cos(phi)),
                    (radius * Math.sin(phi) * Math.sin(theta))
                );
            });
            earth.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), material));
        }

        function addStars() {
            const posArray = new Float32Array(3000);
            for (let i = 0; i < 3000; i++) posArray[i] = (Math.random() - 0.5) * 100;
            const starGeo = new THREE.BufferGeometry();
            starGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            scene.add(new THREE.Points(starGeo, new THREE.PointsMaterial({ size: 0.1, color: 0xffffff })));
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (controls) controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>

</html>